diff --git a/src/Perl6/Grammar.nqp b/src/Perl6/Grammar.nqp
index e2f5e7b..3491c02 100644
--- a/src/Perl6/Grammar.nqp
+++ b/src/Perl6/Grammar.nqp
@@ -821,6 +821,7 @@ grammar Perl6::Grammar is HLL::Grammar does STD {
         
         # Quasis and unquotes
         :my $*IN_QUASI := 0;                       # whether we're currently in a quasi block
+        :my $*MAIN := 'MAIN';
 
         # Setting loading and symbol setup.
         {
@@ -889,6 +890,9 @@ grammar Perl6::Grammar is HLL::Grammar does STD {
                     %*LANG{$_.key} := $_.value;
                 }
             }
+            if $have_outer && $*UNIT_OUTER.symbol('$*MAIN') {
+                $*MAIN := $*UNIT_OUTER.symbol('$*MAIN')<value>;
+            }
             
             # Install unless we've no setting, in which case we've likely no
             # static lexpad class yet either. Also, UNIT needs a code object.
@@ -911,7 +915,7 @@ grammar Perl6::Grammar is HLL::Grammar does STD {
         
         <.finishpad>
         <.bom>?
-        <statementlist>
+        <statementlist=.LANG($*MAIN, 'statementlist')>
 
         <.install_doc_phaser>
         
@@ -1226,10 +1230,18 @@ grammar Perl6::Grammar is HLL::Grammar does STD {
         :my $*IN_DECL := 'use';
         :my $*HAS_SELF := '';
         :my $*SCOPE   := 'use';
+        :my $OLD_MAIN := ~$*MAIN;
         $<doc>=[ 'DOC' \h+ ]**0..1
         <sym> <.ws>
         [
-        | <version>
+        | <version> [ <?{ ~$<version><vnum>[0] eq '5' }> {
+                        my $module := $*W.load_module($/, 'Perl5', {}, $*GLOBALish);
+                        do_import($/, $module, 'Perl5');
+                        $/.CURSOR.import_EXPORTHOW($module);
+                    } ]?
+                    [ <?{ ~$<version><vnum>[0] eq '6' }> {
+                        $*MAIN := 'MAIN';
+                    } ]?
         | <module_name>
             {
                 $longname := $<module_name><longname>;
@@ -1280,6 +1292,15 @@ grammar Perl6::Grammar is HLL::Grammar does STD {
                 }
             ]
         ]
+        [ <?{ $*MAIN ne $OLD_MAIN }> {
+            if $*MAIN eq 'Perl5' { # ó.ò
+                my $terms := $*W.load_module($/, 'Perl5::Terms', {}, $*GLOBALish);
+                do_import($/, $terms, 'Perl5::Terms');
+                $/.CURSOR.import_EXPORTHOW($terms);
+            }
+            $*IN_DECL := '';
+            $*SCOPE := '';
+        } <statementlist=.LANG($*MAIN, 'statementlist')> ]?
         <.ws>
     }
     
diff --git a/src/Perl6/ModuleLoader.nqp b/src/Perl6/ModuleLoader.nqp
index 6ee6130..6a45d4f 100644
--- a/src/Perl6/ModuleLoader.nqp
+++ b/src/Perl6/ModuleLoader.nqp
@@ -23,14 +23,31 @@ class Perl6::ModuleLoader does Perl6::ModuleLoaderVMConfig {
         $*CTXSAVE := 0;
     }
     
-    method search_path() {
+    method search_path(:$from) {
         # See if we have an @*INC set up, and if so just use that.
         my $PROCESS := nqp::gethllsym('perl6', 'PROCESS');
+        if $from && !nqp::isnull($PROCESS) && nqp::existskey($PROCESS.WHO, '%CUSTOM_LIB') {
+            my $INC := ($PROCESS.WHO)<%CUSTOM_LIB>;
+                if nqp::defined($INC) {
+                my %INC := $INC.FLATTENABLE_HASH();
+                if nqp::existskey(%INC, $from) {
+                    my @INC := %INC<Perl5>.FLATTENABLE_LIST();
+                    if +@INC {
+                        return @INC;
+                    }
+                }
+            }
+        }
+
         if !nqp::isnull($PROCESS) && nqp::existskey($PROCESS.WHO, '@INC') {
             my $INC := ($PROCESS.WHO)<@INC>;
             if nqp::defined($INC) {
                 my @INC := $INC.FLATTENABLE_LIST();
                 if +@INC {
+                    if $from {
+                        my %conf := pir::getinterp__P()[pir::const::IGLOBALS_CONFIG_HASH];
+                        nqp::push(@INC, %conf<libdir> ~ %conf<versiondir> ~ '/languages/' ~ nqp::lc($from) ~ '/lib');
+                    }
                     return @INC;
                 }
             }
@@ -54,14 +71,14 @@ class Perl6::ModuleLoader does Perl6::ModuleLoaderVMConfig {
                 return %language_module_loaders{%opts<from>}.load_module($module_name,
                     %opts, |@GLOBALish, :$line, :$file);
             }
-            else {
-                nqp::die("Do not know how to load code from " ~ %opts<from>);
-            }
+            #~ else {
+                #~ nqp::die("Do not know how to load code from " ~ %opts<from>);
+            #~ }
         }
         
         # Locate all the things that we potentially could load. Choose
         # the first one for now (XXX need to filter by version and auth).
-        my @prefixes   := self.search_path();
+        my @prefixes   := self.search_path( :from(%opts<from>) );
         my @candidates := self.locate_candidates($module_name, @prefixes, :$file);
         if +@candidates == 0 {
             if nqp::defined($file) {
@@ -143,7 +160,7 @@ class Perl6::ModuleLoader does Perl6::ModuleLoaderVMConfig {
                 # Get the compiler and compile the code, then run it
                 # (which runs the mainline and captures UNIT).
                 my $?FILES   := %chosen<pm>;
-                my $eval     := nqp::getcomp('perl6').compile($source);
+                my $eval     := nqp::getcomp('perl6').compile($source, :M(%opts<from>));
                 my $*CTXSAVE := self;
                 my $*MAIN_CTX;
                 $eval();
